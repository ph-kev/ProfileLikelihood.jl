var documenterSearchIndex = {"docs":
[{"location":"api/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"api/#Public-API","page":"Documentation","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"Documentation for ProfileLikelihood.jl's public functions. ","category":"page"},{"location":"api/#Error/objective-functions","page":"Documentation","title":"Error/objective functions","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"relative_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real}, \n                        noise_level::Real) ","category":"page"},{"location":"api/#ProfileLikelihood.relative_error-Tuple{AbstractVector{var\"#s77\"} where var\"#s77\"<:Real, AbstractVector{var\"#s76\"} where var\"#s76\"<:Real, Real}","page":"Documentation","title":"ProfileLikelihood.relative_error","text":"relative_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real}, \n               noise_level::Real)\n\nThe objective function for when the noise in the data follow relative error. \n\nThe objective function is\n\nhatθ = arg min_θ frac1η^2 sum_i=1^n left( fracy_i - g(t_iθ)g(t_iθ) right)^2 + 2 sum_i=1^n log g(t_iθ)\n\nwhere η is the noise level, g(t_iθ) is the ith point of the predicted solution,  and y_i is the ith data point. \n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Documentation","title":"Documentation","text":"poisson_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real}) ","category":"page"},{"location":"api/#ProfileLikelihood.poisson_error-Tuple{AbstractVector{var\"#s77\"} where var\"#s77\"<:Real, AbstractVector{var\"#s76\"} where var\"#s76\"<:Real}","page":"Documentation","title":"ProfileLikelihood.poisson_error","text":"poisson_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real})\n\nThe objective function for when the data follow a Poisson distribution. \n\nThe objective function is\n\nhatθ = arg min_θ -sum_i=1^n log (g(t_iuθ)^y_i) + sum_i=1^n g(t_iuθ)\n\nwhere g(t_iθ) is the ith point of the predicted solution  and y_i is the ith data point.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Documentation","title":"Documentation","text":"const_variance_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real}, sigma::Real)","category":"page"},{"location":"api/#ProfileLikelihood.const_variance_error-Tuple{AbstractVector{var\"#s77\"} where var\"#s77\"<:Real, AbstractVector{var\"#s76\"} where var\"#s76\"<:Real, Real}","page":"Documentation","title":"ProfileLikelihood.const_variance_error","text":"const_variance_error(data::AbstractVector{<:Real}, sol::AbstractVector{<:Real}, \n                     sigma::Real)\n\nThe objective function for when the data follow a normal distribution with mean 0 and  known variance sigma^2. \n\nThe objective function is \n\nhatθ = arg min_θ sum_i=1^n (y_i - g(t_iuθ))^2  sigma^2\n\nwhere g(t_iθ) is the ith point of the predicted solution  and y_i is the ith data point.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Documentation","title":"Documentation","text":"likelihood_const(obj::String; noise_level::Real=0.0, times::AbstractVector{<:Real}=Vector{Real}(), data::AbstractVector{<:Real}=Vector{Real}(), sigma::Real = -1.0) ","category":"page"},{"location":"api/#ProfileLikelihood.likelihood_const-Tuple{String}","page":"Documentation","title":"ProfileLikelihood.likelihood_const","text":"likelihood_const(obj::String; \n                 noise_level::Real=0.0, \n                 times::AbstractVector{<:Real}=Vector{Real}(), \n                 data::AbstractVector{<:Real}=Vector{Real}(), \n                 sigma::Real = -1.0)\n\nThis gives the constant in the likelihood function when the error is assumed to follow  relative error or constant variance error or when the data is assumed to follow a Poisson  distribution.\n\nThe constant for the likelihood function is often dropped when finding the minimizer of the  likelihood function. We typically add this back when generating the profile likelihood plots.  For relative error, the constant is \n\nn log η^2 + n log 2 π\n\nwhere η is the noise level and n is the number of data points. For constant variance  error, the constant is \n\nn log 2π + n log σ^2\n\nwhere σ is the standard deviation of the error and n is the number of data points. For poisson error, the constant is \n\nsum_i=1^n log (y_i)\n\nwhere n is the number of data points and y_i is the ith data point of the  observable y. \n\n\n\n\n\n","category":"method"},{"location":"api/#Generate-data","page":"Documentation","title":"Generate data","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"generate_data(index::Integer, seed::Integer, dist::Function, \n                       prob::SciMLBase.AbstractDEProblem, \n                       alg::SciMLBase.AbstractDEAlgorithm, \n                       times::AbstractVector{<:Real}; \n                       incidence_obs_status::Bool = false, \n                       kwargs...)","category":"page"},{"location":"api/#ProfileLikelihood.generate_data-Tuple{Integer, Integer, Function, SciMLBase.AbstractDEProblem, SciMLBase.AbstractDEAlgorithm, AbstractVector{var\"#s77\"} where var\"#s77\"<:Real}","page":"Documentation","title":"ProfileLikelihood.generate_data","text":"generate_data(index::Integer, seed::Integer, dist::Function, \n              prob::SciMLBase.AbstractDEProblem, \n              alg::SciMLBase.AbstractDEAlgorithm, \n              times::AbstractVector{<:Real}; \n              incidence_obs_status::Bool = false, \n              kwargs...)\n\nThis generates perfect and noisy data and incidence data of the state variables of the  system of differential equations. \n\nLet mathcalIt_0t_1dotst_n rightarrow mathbbR be the number of incidences defined by  0 if t=t_0 and mathcalC(t_i) - mathcalC(t_i-1) if t neq t_0 where mathcalC is cumulative data. Note that times is t_0t_1dotst_n.\n\nArguments\n\nindex::Integer: Index of the component of the state variables for data collection.\nseed::Integer: Seed of RNG generator. Set for reproducible results. \ndist::Function: Function to generate noisy data. The inputs are the data points sampled at points in times.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\n\nKeywords\n\nincidence_obs_status::Bool = false: Determine whether the data is incidence data or not. If true, the indexth state variable must be cumulative data.\nkwargs...: Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\n\nReturns\n\nperfect_data: Data without noise.\nnoisy_data: Data with noise according to dist.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Documentation","title":"Documentation","text":"generate_incidence_data(index::Integer, \n                                 prob::SciMLBase.AbstractDEProblem, \n                                 alg::SciMLBase.AbstractDEAlgorithm, \n                                 times::AbstractVector{<:Real}; \n                                 kwargs...)","category":"page"},{"location":"api/#ProfileLikelihood.generate_incidence_data-Tuple{Integer, SciMLBase.AbstractDEProblem, SciMLBase.AbstractDEAlgorithm, AbstractVector{var\"#s77\"} where var\"#s77\"<:Real}","page":"Documentation","title":"ProfileLikelihood.generate_incidence_data","text":"generate_incidence_data(index::Integer, \n                        prob::SciMLBase.AbstractDEProblem, \n                        alg::SciMLBase.AbstractDEAlgorithm, \n                        times::AbstractVector{<:Real}; \n                        kwargs...)\n\nThis generates incidence data without noise by solving the DEs and computing incidence data from cumulative data according to the indexth state variable.\n\nLet mathcalIt_0t_1dotst_n rightarrow mathbbR be the number of incidences defined by  0 if t=t_0 and mathcalC(t_i) - mathcalC(t_i-1) if t neq t_0 where mathcalC is cumulative data. Note that times is t_0t_1dotst_n.\n\nArguments\n\nindex::Integer: Index of the component of the state variables for data collection.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\n\nKeywords\n\nkwargs...: Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\n\nReturns\n\nincidence_data: Incidence data of the indexth state variable which represents cumulative data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Estimating-parameters","page":"Documentation","title":"Estimating parameters","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"estimate_params","category":"page"},{"location":"api/#ProfileLikelihood.estimate_params","page":"Documentation","title":"ProfileLikelihood.estimate_params","text":"estimate_params(p0::AbstractVector{<:Real}, \n                data::AbstractVector{<:AbstractVector{<:Real}}, \n                sol_obs::AbstractVector{<:Integer}, \n                prob::SciMLBase.AbstractDEProblem, \n                alg_diff::SciMLBase.AbstractDEAlgorithm, \n                times::AbstractVector{<:Real}, obj_arr::AbstractVector, \n                alg_opti, \n                lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                incidence_obs::AbstractVector{<:Int}=[], param_index::Int=0, \n                param_eval::Real=0.0, \n                solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n                opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis estimate the parameters of the system of differential equations using the objective functions in obj_arr given prob using the optimization algorithm alg_opti. \n\nEstimation of parameters is done using the objective function array obj_arr where each objective function in the array corresponds to data described by sol_obs and incidence_obs. For instance, if obj_arr = [obj1 obj2],sol_obs = [2], incidence_obs = [3], then obj1 use data corresponding to the second state variable of the DEs and obj2 use incidence data of the third state variable of the DEs. Noisy data or any other type of data should be passed to data and in the same order as in the arrays sol_obs and incidence_obs. Fixing a parameter can be done using param_index. Instead, this return the fitted parameters with param_eval for the fixed parameter and accordingly, the loss is the objective function evaluated at the fitted parameters with param_eval for the fixed parameter. \n\nArguments\n\np0::AbstractVector{<:Real}: Starting guess for optimization. If param_index and param_eval are used, then p0 should not contain the fixed parameter.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.\nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{Function}: Vector of objective functions. \nalg_opti: Optimization algorithm (see Optimization.jl for a list of algorithms that could be used).\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Int}=[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nparam_index::Int=0: Index of the parameter vector that is fixed. \nparam_eval::Real=0.0: Value for the fixed parameter. \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\nminimum: Loss of the fitted parameters according to the objective function(s).\nminimizer: Fitted parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"estimate_params_multistart","category":"page"},{"location":"api/#ProfileLikelihood.estimate_params_multistart","page":"Documentation","title":"ProfileLikelihood.estimate_params_multistart","text":"estimate_params_multistart(p0::AbstractVector{<:Real}, \n                           data::AbstractVector{<:AbstractVector{<:Real}}, \n                           sol_obs::AbstractVector{<:Integer}, \n                           prob::SciMLBase.AbstractDEProblem, \n                           alg_diff::SciMLBase.AbstractDEAlgorithm, \n                           times::AbstractVector{<:Real}, obj_arr::AbstractVector, \n                           alg_opti, \n                           alg_opti_local,\n                           lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                           incidence_obs::AbstractVector{<:Int}=[], param_index::Int=0, \n                           param_eval::Real=0.0, \n                           solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n                           opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis estimate the parameters of the system of differential equations using the objective function obj_arr given prob using the multi-start optimization algorithm alg_opti from MultiStartOptimization and the local optimization algorithm alg_opti_local from the NLopt.jl. \n\nThe algorithm alg_opti is always MultistartOptimization.TikTak(n) where n is the number of starting points generated from the Sobol sequence. MultistartOptimization.jl only support optimziation algorithms from NLopt.jl. The recommended local optimization algorithm is NLopt.LN_NELDERMEAD(). See the docstring for estimate_params for more information for what estimate_params_multistart do. \n\nArguments\n\np0::AbstractVector{<:Real}: Starting guess for optimization. If param_index and param_eval are used, then p0 should not contain the fixed parameter.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.\nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector: Vector of objective functions. \nalg_opti: Global optimization algorithm. Typically, MultistartOptimization.TikTak(n) where n is the number of starting points generated from the Sobol sequence.\nalg_opti_local: Local optimization algorithm. Must be an algorithm from NLopt.jl.\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Int}=[]: Indices of the state variables of the DEs to find incidence data of which is used for sampling data points. The state variables must be cumulative data.  \nparam_index::Int=0: Index of the parameter vector that is fixed. \nparam_eval::Real=0.0: Value for the fixed parameter. \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\nminimum: Loss of the fitted parameters according to the objective function(s).\nminimizer: Fitted parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#Likelihood-function","page":"Documentation","title":"Likelihood function","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"likelihood","category":"page"},{"location":"api/#ProfileLikelihood.likelihood","page":"Documentation","title":"ProfileLikelihood.likelihood","text":"likelihood(params::AbstractVector{<:Real}, \n           data::AbstractVector{<:AbstractVector{<:Real}},\n           sol_obs::AbstractVector{<:Integer}, \n           prob::SciMLBase.AbstractDEProblem, \n           alg::SciMLBase.AbstractDEAlgorithm, \n           times::AbstractVector{<:Real}, \n           obj_arr::AbstractVector{<:Function}; \n           incidence_obs::AbstractVector{<:Integer} = Int64[], \n           param_index::Integer=0, \n           param_eval::Real=0.0, \n           solver_diff_opts::Dict = Dict())::Float64\n\nThis computes the likelihood based on the given parameters params, data, and likelihood functions in obj_arr. \n\nEach objective function in obj_arr corresponds to data described by sol_obs and incidence_obs. For instance, if obj_arr = [obj1 obj2],sol_obs = [2], incidence_obs = [3], then obj1 use data corresponding to the second state variable of the DEs and obj2 use incidence data of the third state variable of the DEs. Noisy data or any other type of data should be passed to data and in the same order as in the arrays sol_obs and incidence_obs. Fixing a parameter can be done using param_index. Instead, this return the fitted parameters with param_eval for the fixed parameter and accordingly, the loss is the objective function evaluated at the fitted parameters with param_eval for the fixed parameter. \n\nArguments\n\nparams::AbstractVector{<:Real}: Parameters to evaluate at. If param_index and param_eval are used, then params should not contain the fixed parameter.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for computing likelihood. data must be in the same order as in sol_obs and incidence_obs.\nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at. \nobj_arr::AbstractVector: Vector of objective functions. \n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer} = []: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.   \nparam_index::Integer=0: Index of the parameter vector that is fixed. \nparam_eval::Real=0.0: Value for the fixed parameter.  \nsolver_diff_opts::Dict = Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\n\nReturns\n\nloss: Likelihood of observing data given params.\n\n\n\n\n\n","category":"function"},{"location":"api/#Threshold","page":"Documentation","title":"Threshold","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"find_threshold(confidence::Real, nums_params::Integer, loss::Real)","category":"page"},{"location":"api/#ProfileLikelihood.find_threshold-Tuple{Real, Integer, Real}","page":"Documentation","title":"ProfileLikelihood.find_threshold","text":"find_threshold(confidence::Real, nums_params::Integer, loss::Real)\n\nThis finds the threshold used for calculating likelihood-based confidence intervals. \n\nThe threshold Δ_α is the α quantile of the χ^2 distribution with df=1 for pointwise  confidence intervals and df=# of parameters for simulataneous confidence intervals.\n\nArguments\n\nconfidence::Real: Level of confidence used for confidence interval. \nnums_params::Integer: Number of parameters. df = 1 for pointwise confidence intervals and df = number of unknown parameters for simulataneous confidence intervals.\nloss:Real: Minimum loss according to negative log-likelihood function after optimization.\n\nReturn\n\nthreshold: Threshold used for likelihood-based confidence interval. \n\n\n\n\n\n","category":"method"},{"location":"api/#Finding-profile-likelihood","page":"Documentation","title":"Finding profile likelihood","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"find_profile_likelihood","category":"page"},{"location":"api/#ProfileLikelihood.find_profile_likelihood","page":"Documentation","title":"ProfileLikelihood.find_profile_likelihood","text":"find_profile_likelihood(step_size::Real, max_steps::Integer, param_index::Integer,\n                        param_fitted::AbstractVector{<:Real}, \n                        data::AbstractVector{<:AbstractVector{<:Real}}, \n                        sol_obs::AbstractVector{<:Integer}, \n                        threshold::Real, loss::Real, \n                        prob::SciMLBase.AbstractDEProblem, \n                        alg_diff::SciMLBase.AbstractDEAlgorithm,\n                        times::AbstractVector{<:Real},\n                        obj_arr::AbstractVector, \n                        alg_opti, \n                        lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                        incidence_obs::AbstractVector{<:Integer}=Int64[], \n                        solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n                        opti_solver_opts::Dict=Dict(), \n                        print_status::Bool=false, pl_const::Real=0.0)\n\nThis find the profile likelihood of the param_indexth parameter in param_fitted. \n\nThis implements a simple fixed step size algorithm to compute profile likelihood. It start at  the minimum point of the profile likelihood and take step in the right direction and left direction. The algorithm stop taking steps if the maximum allowed steps max_step is reached or if the  points being computed is above the threshold. \n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Optimization algorithm (see Optimization.jl for a list of algorithms that could be used).\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \npl_const::Real=0.0: Constant that is added to loss of the computed points. The constant can be computed by likelihood_const.\n\nReturns\n\ntheta: Values of the fixed parameter that is explored.\nsol: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"find_profile_likelihood_multistart","category":"page"},{"location":"api/#ProfileLikelihood.find_profile_likelihood_multistart","page":"Documentation","title":"ProfileLikelihood.find_profile_likelihood_multistart","text":"find_profile_likelihood_multistart(step_size::Real, max_steps::Integer, param_index::Integer, \n                                   param_fitted::AbstractVector{<:Real}, \n                                   data::AbstractVector{<:AbstractVector{<:Real}}, \n                                   sol_obs::AbstractVector{<:Integer}, \n                                   threshold::Real, loss::Real, \n                                   prob::SciMLBase.AbstractDEProblem, \n                                   alg_diff::SciMLBase.AbstractDEAlgorithm,  \n                                   times::AbstractVector{<:Real}, \n                                   obj_arr::AbstractVector{<:Function}, \n                                   alg_opti, alg_opti_local, \n                                   lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                                   incidence_obs::AbstractVector{<:Integer}=Int64[], \n                                   solver_diff_opts=Dict(), opti_prob_opts=Dict(), \n                                   opti_solver_opts=Dict(), \n                                   print_status::Bool=false, pl_const::Real=0.0)\n\nThis find the profile likelihood of the param_indexth parameter in param_fitted. \n\nThis implements a simple fixed step size algorithm to compute profile likelihood. It start at  the minimum point of the profile likelihood and take step in the right direction and left direction. The algorithm stop taking steps if the maximum allowed steps max_step is reached or if the  points being computed is above the threshold. The difference between find_profile_likelihood and find_profile_likelihood_multistart is that this function uses the multi-start optimization algorithm alg_opti from MultiStartOptimization and the local optimization algorithm alg_opti_local from the NLopt.jl. This is similar to the differences between estimate_params and estimate_params_multistart.\n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Global optimization algorithm. Typically, MultistartOptimization.TikTak(n) where n is the number of starting points generated from the Sobol sequence.\nalg_opti_local: Local optimization algorithm. Must be an algorithm from NLopt.jl.\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \npl_const::Real=0.0: Constant that is added to loss of the computed points. The constant can be computed by likelihood_const.\n\nReturns\n\ntheta: Values of the fixed parameter that is explored.\nsol: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"api/#Processing-data","page":"Documentation","title":"Processing data","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"find_roots","category":"page"},{"location":"api/#ProfileLikelihood.find_roots","page":"Documentation","title":"ProfileLikelihood.find_roots","text":"find_roots(interpolation, theta::AbstractVector{<:Real}, threshold::Real)\n\nThis finds the intercepts of the threshold and χ^2 which corresponds to the confidence  intervals. \n\ninterpolation is a function which takes in a single input \n\nArguments\n\ninterpolation: Function which takes in a single input x and output χ^2(x) where χ^2 is profile likelihood. This should be an interpolation of the points found using PL.\ntheta::AbstractVector{<:Real}: Values of θ searched using PL.\nthreshold::Real: threshold found using find_threshold. If pl_const was used in PL, then also add pl_const to threshold.\n\nReturns\n\nres: Intercepts of the threshold and χ^2 which corresponds to the confidence interval.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internals","page":"Documentation","title":"Internals","text":"","category":"section"},{"location":"api/","page":"Documentation","title":"Documentation","text":"Documentation for ProfileLikelihood.jl's private functions which are not intended for use. ","category":"page"},{"location":"api/","page":"Documentation","title":"Documentation","text":"generate_incidence_data(sol::AbstractVector{<:Real}) ","category":"page"},{"location":"api/#ProfileLikelihood.generate_incidence_data-Tuple{AbstractVector{var\"#s77\"} where var\"#s77\"<:Real}","page":"Documentation","title":"ProfileLikelihood.generate_incidence_data","text":"generate_incidence_data(sol::AbstractVector{<:Real})\n\nThis generates incidence data from cumulative data.\n\nLet mathcalIt_0t_1dotst_n rightarrow mathbbR be the number of incidences defined by  0 if t=t_0 and mathcalC(t_i) - mathcalC(t_i-1) if t neq t_0 where mathcalC is cumulative data.\n\nArguments\n\nsol::AbstractVector{<:Real}: Vector of cumulative data.\n\nReturns\n\nincidence_data: Incidence data calculated from cumulative data.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Documentation","title":"Documentation","text":"ProfileLikelihood.min_point","category":"page"},{"location":"api/#ProfileLikelihood.min_point","page":"Documentation","title":"ProfileLikelihood.min_point","text":"min_point(param_index::Integer, loss::Real, param_fitted::AbstractVector{<:Real})\n\nThis returns the minimum point of the profile likelihood plot where the point is  (indexth element of param_fitted,loss).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"ProfileLikelihood.go_right_PL","category":"page"},{"location":"api/#ProfileLikelihood.go_right_PL","page":"Documentation","title":"ProfileLikelihood.go_right_PL","text":"go_right_PL(step_size::Real, max_steps::Integer, param_index::Integer, \n            param_fitted::AbstractVector{<:Real}, \n            data::AbstractVector{<:AbstractVector{<:Real}}, \n            sol_obs::AbstractVector{<:Integer}, \n            threshold::Real, loss::Real, \n            prob::SciMLBase.AbstractDEProblem, \n            alg_diff::SciMLBase.AbstractDEAlgorithm, \n            times::AbstractVector{<:Real}, \n            obj_arr::AbstractVector{<:Function}, \n            alg_opti, \n            lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n            incidence_obs::AbstractVector{<:Integer}=Int64[], \n            solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n            opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis compute the points to the right of the minimum point of the profile likelihood.\n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Optimization algorithm (see Optimization.jl for a list of algorithms that could be used).\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\ntheta_right: Values of the fixed parameter that is explored to the right of the minimum point.\nsol_right: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"ProfileLikelihood.go_left_PL","category":"page"},{"location":"api/#ProfileLikelihood.go_left_PL","page":"Documentation","title":"ProfileLikelihood.go_left_PL","text":"go_left_PL(step_size::Real, max_steps::Integer, param_index::Integer, \n           param_fitted::AbstractVector{<:Real}, \n           data::AbstractVector{<:AbstractVector{<:Real}}, \n           sol_obs::AbstractVector{<:Integer}, \n           threshold::Real, loss::Real, \n           prob::SciMLBase.AbstractDEProblem, \n           alg_diff::SciMLBase.AbstractDEAlgorithm, \n           times::AbstractVector{<:Real}, \n           obj_arr::AbstractVector{<:Function}, \n           alg_opti, \n           lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n           incidence_obs::AbstractVector{<:Integer}=Int64[],  \n           solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n           opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis compute the points to the left of the minimum point of the profile likelihood.\n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Optimization algorithm (see Optimization.jl for a list of algorithms that could be used).\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\ntheta_left: Values of the fixed parameter that is explored to the left of the minimum point.\nsol_left: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"ProfileLikelihood.go_right_PL_multistart","category":"page"},{"location":"api/#ProfileLikelihood.go_right_PL_multistart","page":"Documentation","title":"ProfileLikelihood.go_right_PL_multistart","text":"go_right_PL_multistart(step_size::Real, max_steps::Integer, param_index::Integer, \n                       param_fitted::AbstractVector{<:Real}, \n                       data::AbstractVector{<:AbstractVector{<:Real}}, \n                       sol_obs::AbstractVector{<:Integer}, \n                       threshold::Real, loss::Real, \n                       prob::SciMLBase.AbstractDEProblem, \n                       alg_diff::SciMLBase.AbstractDEAlgorithm, \n                       times::AbstractVector{<:Real}, \n                       obj_arr::AbstractVector::{<:Function}, \n                       alg_opti, alg_opti_local\n                       lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                       incidence_obs::AbstractVector{<:Integer}=Int64[], \n                       solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n                       opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis compute the points to the right of the minimum point of the profile likelihood.\n\nThis is used by find_profile_likelihood_multistart.\n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Global optimization algorithm. Typically, MultistartOptimization.TikTak(n) where n is the number of starting points generated from the Sobol sequence.\nalg_opti_local: Local optimization algorithm. Must be an algorithm from NLopt.jl.\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\ntheta_right: Values of the fixed parameter that is explored to the right of the minimum point.\nsol_right: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Documentation","title":"Documentation","text":"ProfileLikelihood.go_left_PL_multistart","category":"page"},{"location":"api/#ProfileLikelihood.go_left_PL_multistart","page":"Documentation","title":"ProfileLikelihood.go_left_PL_multistart","text":"go_left_PL_multistart(step_size::Real, max_steps::Integer, param_index::Integer, \n                      param_fitted::AbstractVector{<:Real}, \n                      data::AbstractVector{<:AbstractVector{<:Real}}, \n                      sol_obs::AbstractVector{<:Integer}, \n                      threshold::Real, loss::Real, \n                      prob::SciMLBase.AbstractDEProblem, \n                      alg_diff::SciMLBase.AbstractDEAlgorithm, \n                      times::AbstractVector{<:Real}, \n                      obj_arr::AbstractVector{<:Function}, \n                      alg_opti, alg_opti_local\n                      lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real}; \n                      incidence_obs::AbstractVector{<:Integer}=Int64[], \n                      solver_diff_opts::Dict=Dict(), opti_prob_opts::Dict=Dict(), \n                      opti_solver_opts::Dict=Dict(), print_status::Bool=false)\n\nThis compute the points to the left of the minimum point of the profile likelihood.\n\nThis is used by find_profile_likelihood_multistart.\n\nArguments\n\nstep_size::Real: Step size to take for computing points.\nmax_steps::Integer: Maximum steps allowed.\nparam_index::Integer: Index of the parameter vector that is fixed. \nparam_fitted::AbstractVector{<:Real}: Optimized parameters. Should be the return vector minimizer of estimate_params or estimate_params_multistart.\ndata::AbstractVector{<:AbstractVector{<:Real}}: Vector of data used for optimizing parameters. data must be in the same order as in sol_obs and incidence_obs.  \nsol_obs::AbstractVector{<:Integer}: Indices of the state variables of the DEs to be used for sampling data points. \nthreshold::Real: Value for which the algorithm will stop computing points if the loss of the computed points is greater than the threshold. Does not necessarily need to be the same threshold as the threshold value in find_threshold.\nloss::Real: Loss of the fitted parameters according to the objective function(s). Should be the return value minimum of estimate_params or estimate_params_multistart.\nprob::SciMLBase.AbstractDEProblem: DE Problem (see DifferentialEquations.jl for more information).\nalg_diff::SciMLBase.AbstractDEAlgorithm: DE Solver Algorithm (see DifferentialEquations.jl for more information).\ntimes::AbstractVector{<:Real}: Times that the data points will be sampled at.\nobj_arr::AbstractVector{<:Function}: Vector of objective functions. \nalg_opti: Global optimization algorithm. Typically, MultistartOptimization.TikTak(n) where n is the number of starting points generated from the Sobol sequence.\nalg_opti_local: Local optimization algorithm. Must be an algorithm from NLopt.jl.\nlb::AbstractVector{<:Real}: Lower bound (does not need to be changed if param_index and param_eval are used).\nub::AbstractVector{<:Real}: Upper bound (does not need to be changed if param_index and param_eval are used).\n\nKeywords\n\nincidence_obs::AbstractVector{<:Integer}=Int64[]: Indices of the state variables of the DEs to find incidence data of. The state variables must be cumulative data.  \nsolver_diff_opts::Dict=Dict(): Keyword arguments to be passed into the DE solver. See DifferentialEquations.jl's Common Solver Options.\nopti_prob_opts::Dict=Dict(): Keyword arguments to be passed into the optimization problem. See Optimization.jl's Defining OptimizationProblems.\nopti_solver_opts::Dict=Dict(): Keyword arguments to be passed into the optimization solver. See Optimization.jl's Common Solver Options.\nprint_status::Bool=false: Determine whether the orginal output of the optimization algorithm is printed or not. \n\nReturns\n\ntheta_right: Values of the fixed parameter that is explored to the left of the minimum point.\nsol_right: Value of likelihood computed at the fixed parameter where the other parameters are optimized.\n\n\n\n\n\n","category":"function"},{"location":"#ProfileLikelihood.jl:-Estimating-Parameters-and-Finding-Profile-Likelihood","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"Pages = [\"index.md\",\n         \"optimizer.md\",\n         \"tutorial.md\",\n         \"api.md\",]\nDepth = 1","category":"page"},{"location":"#Installation","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"Installation","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"To install, use the following commands inside Julia REPL: ","category":"page"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"julia> ]\n\n(@v1.7) pkg> add github.com/ph-kev/ProfileLikelihood.jl","category":"page"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"To use the package, add the command: ","category":"page"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"using ProfileLikelihood","category":"page"},{"location":"#Introduction","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"Introduction","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"The package ProfileLikelihood.jl provide methods for generating perfect and noisy data,  estimating parameters, generating profile likelihood, and finding confidence intervals of the estimated parameters. This package is written in mind for use in epidemiology, but it should work well for other fields such as systems biology. More information can be found at Raul et. al.'s \"... exploiting the profile likelihood\" which introduces the method of profile likelihood in the field of systems biology [1].","category":"page"},{"location":"#Features","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"Features","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"Generate perfect and noisy data from the state variables of a system of differential equations \nGenerate incidence data from cumulative data \nBuilt-in objective functions derived from maximum likelihood estimation when the error follows relative error or constant variance error or when the data follow a Poisson distribution\nUtilize the Optimization.jl package which allow for optimization methods from the packages BlackBoxOptim.jl, Evolutionary.jl, Metaheuristics.jl, MultistartOptimization.jl, NLopt.jl, NOMAD.jl, and Optim.jl\nImplemented a simple fixed step-size algorithm to find the profile likelihood \nFind the confidence intervals of the estimated parameters using likelihood-based approach ","category":"page"},{"location":"#Limitations","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"Limitations","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"No support for different types of data taken at different time points \nNo adaptive step size algorithm to find the profile likelihood \nNo support for finding a two-dimensional profile likelihood where two parameters are fixed as opposed to one parameter being fixed  \nNo support for automatic differentiation of the likelihood function ","category":"page"},{"location":"#References","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"References","text":"","category":"section"},{"location":"","page":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","title":"ProfileLikelihood.jl: Estimating Parameters and Finding Profile Likelihood","text":"[1] A. Raue, C. Kreutz, T. Maiwald, J. Bachmann, M. Schilling, U. Klingmüller, J. Timmer, Structural and practical identifiability analysis of partially observed dynamical models by exploiting the profile likelihood, Bioinformatics, Volume 25, Issue 15, 1 August 2009, Pages 1923–1929, https://doi.org/10.1093/bioinformatics/btp358","category":"page"},{"location":"optimizer/#Optimizers","page":"Optimizers","title":"Optimizers","text":"","category":"section"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"The package ProfileLikelihood.jl utilizes Optimization.jl to exports a variety of optimization methods. ProfileLikelihood.jl currently supports optimization methods from ","category":"page"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"BlackBoxOptim.jl,\nEvolutionary.jl, \nMetaheuristics.jl, \nMultistartOptimization.jl, \nNLopt.jl,\nNOMAD.jl,\nOptim.jl. ","category":"page"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"See Optimization.jl and ProfileLikelihood.jl documentation to further understand  how to use the optimization methods. Another resource is the tutorial and the examples folder on the Github of this package.","category":"page"},{"location":"optimizer/#Note-on-Optimization","page":"Optimizers","title":"Note on Optimization","text":"","category":"section"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"For generating profile likelihood plots, we must find the global minimum for each point of the profile likelihood plots. Finding the global minimum is much more difficult than finding the  local minimum. Thus, it is recommended that after finding the global minimum to use another optimization method to ensure that the global minimum is actually found.","category":"page"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"Note that this is based on personal experience on using these optimization methods. For generating profile likelihood plots, I recommend the following optimization methods: ","category":"page"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"NOMADOpt() from NOMAD.jl,\nBBO_generating_set_search() from BlackBoxOptim.jl,\nOptimizationMetaheuristics.DE() from Metaheuristics.jl,\nMultistartOptimization.TikTak(n) with NLopt.LN_NELDERMEAD from MultistartOptimization.jl and NLopt.jl","category":"page"},{"location":"optimizer/","page":"Optimizers","title":"Optimizers","text":"from most recommended to least recommended. NOMADOpt() is reasonably accurate and fast at  finding the global minimum compared to the rest of the methods. However, BBO_generating_set_search() is the most accurate at finding the global minimum, but  is typically the slowest. OptimizationMetaheuristics.DE() and MultistartOptimization.TikTak(n) with NLopt.LN_NELDERMEAD are other global optimization methods that could be used to check whether the global minimum is found. ","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial highlights how ProfileLikelihood.jl can be used to generate data, estimate parameters, and find the profile likelihood. Furthermore, profile likelihood can be used for identifiability analysis and confidence intervals estimation. It is recommend to read the documentation for more information.","category":"page"},{"location":"tutorial/#Packages","page":"Tutorial","title":"Packages","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We load some useful packages.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using ProfileLikelihood, DifferentialEquations, Distributions, # for finding PL\nPlots, LaTeXStrings, Measures, # for plotting\nInterpolations # for finding CI","category":"page"},{"location":"tutorial/#Setting-up-the-problem","page":"Tutorial","title":"Setting up the problem","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will consider the simple SIR model. To set this up, we will use the DifferentialEquations.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function sir!(du, u, p, t)\n    let (S, I, R, C, beta, gamma) = (u[1], u[2], u[3], u[4], p[1], p[2])\n        du[1] = - beta * S * I\n        du[2] = beta * S * I - gamma * I\n        du[3] = gamma * I\n        du[4] = beta * S * I\n    end\nend\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that none of the parameters are known. If we want to make a parameter known, we can simply put it as a const global variable. For instance, if we want to make beta known as 0.01, we would add the line const beta = 0.0001 before defining the function sir!. Also, the variable C is the cumulative data of the infected.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now set up the time span, initial conditions, and true parameters for the differential equation solver.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tspan = (0.0, 40.0)\np0 = [0.0001, 0.1]\nu0 = [10000.0, 10.0, 0.0, 10.0]\nprob = ODEProblem(sir!, u0, tspan, p0)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let plot what the solutions to the SIR model look like using the Plots.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sol = solve(prob, Tsit5(), reltol=1e-5, abstol=1e-10, dense=true)\nsol_plot = plot(sol,plotdensity=1000, labels = [\"Suspectible\" \"Infected\" \"Recovered\" \"Cumulative Infected\"])","category":"page"},{"location":"tutorial/#Generating-data","page":"Tutorial","title":"Generating data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let generate fake data to work with using the function generate_data. We will generate data of recovered and incidence data of infected. We will generate data at t=0, t=1, ..., and t=10. The second input to generate_data is the seed of the random number generator in case if noise is added. The third input accepts a function whose input are the values of the data points and output the noisy data. For this tutorial, we will add noise from the normal distribution and Poisson distribution using the Distributions.jl package. We will use the anonymous functions i -> truncated(Normal(i,30), lower = 0) i -> Poisson(i) to add noise. Note that if we want incidence data from cumulative data, we need to set incidence_obs_status=true. Also, we can pass keyword arguments to the differential equation solver the same way we did when we solve the differential equation earlier.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"times = LinRange{Float64}(0.0, 10.0, 11)\nperfect_data_recovered, noisy_data_recovered = generate_data(3, 111, i -> truncated(Normal(i,30), lower=0),\nprob, Tsit5(), times; incidence_obs_status=false, abstol=1e-10, reltol=1e-5)\nperfect_data_incidence_infected, noisy_data_incidence_infected = generate_data(4, 111,\ni -> Poisson(i), prob, Tsit5(), times; incidence_obs_status=true, abstol=1e-10, reltol=1e-5)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let plot the perfect and noisy data of recovered!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt_recovered = plot(times, perfect_data_recovered, dpi = 400,\nlabels = \"Perfect Recovered Data\", xlabel = L\"t\", ylabel = \"Recovered Data\")\nplot!(times, noisy_data_recovered, labels = \"Noisy Recovered Data\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let also plot the perfect and noisy incidence data of infected!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plt_incidence_infected = plot(times, perfect_data_incidence_infected, dpi = 400,\nlabels = \"Perfect Incidence Data\", xlabel = L\"t\", ylabel = \"Incidence Data of Infected\")\nplot!(times, noisy_data_incidence_infected, labels = \"Noisy Incidence Infected Data\")","category":"page"},{"location":"tutorial/#Estimating-parameters","page":"Tutorial","title":"Estimating parameters","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Since there is only data from t=0 to t=10, we can change tspan and remake the ODE problem. This saves the computer from doing unnecessary computations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tspan = (0.0, 10.0)\nprob = remake(prob; tspan = tspan)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let fit the SIR model to the noisy data that we have generated. The package ProfileLikelihood.jl already have objective functions derived from maxmimum likelihood estimation. The third input of const_variance_error is the standard deviation of the noise distribution which is σ = 30.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obj_const_variance = (data, sol) -> const_variance_error(data, sol, 30.0)\nobj_poisson = (data, sol) -> poisson_error(data, sol)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To estimate parameters, we use the function estimate_params. This accepts the keywords solver_diff_opts, opti_prob_opts, and opti_solver_opts for the differential equation solver, optimization problem, and optimization solver. See the documentation for more information.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"solver_diff_opts = Dict(\n    :reltol => 1e-5,\n    :abstol => 1e-10,\n)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first input to estimate_params is the initial guess of parameters, the second input is any non-incidence data, and the third input is the indices of the state variables of the DEs that we are interested in. The eighth, ninth, and tenth inputs are the optimizaiton algorithm, lower bounds, and upper bounds. For more information, see the ProfileLikelihood.jl documentation and Optimization.jl documentation. For this tutorial, we will use the NOMADOpt() optimization algorithm from the package NOMAD.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"initial_guess = [1.0, 1.0]\nloss, fitted_params = estimate_params(initial_guess, [noisy_data_recovered, noisy_data_incidence_infected],\n[3], prob, Tsit5(), times, [obj_const_variance, obj_poisson], NOMADOpt(), [0.0, 0.0], [3.0, 3.0];\nincidence_obs = [4], solver_diff_opts=solver_diff_opts)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This does not look quite right as we know the true parameters is [0.0001, 0.1]. We will try again with another optimization algorithm. We will use the DE() algorithm from the Metaheuristics.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"loss, fitted_params = estimate_params(initial_guess, [noisy_data_recovered, noisy_data_incidence_infected],\n[3], prob, Tsit5(), times, [obj_const_variance, obj_poisson], OptimizationMetaheuristics.DE(N=50),\n[0.0, 0.0], [3.0, 3.0]; incidence_obs = [4], solver_diff_opts=solver_diff_opts, print_status = true)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To make sure this is the global minimum, we can use another optimization algorithm. We will use the generating_set_search from BlackBoxOptim.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"opti_solver_opts = Dict(\n    :maxtime => 120.0, # how long for it to run in seconds\n    :f_calls_limit => 1000000,\n    :iterations => 2000000,\n    :TraceInterval => 10.0 # print results every 10.0 seconds\n)\n\nloss, fitted_params = estimate_params(initial_guess, [noisy_data_recovered, noisy_data_incidence_infected],\n[3], prob, Tsit5(), times, [obj_const_variance, obj_poisson], BBO_generating_set_search(),\n[0.0, 0.0], [3.0, 3.0]; incidence_obs = [4], solver_diff_opts=solver_diff_opts,\nopti_solver_opts = opti_solver_opts)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"That matches close with what we got with the DE() algorithm from the Metaheuristics.jl package!","category":"page"},{"location":"tutorial/#Threshold-and-constants","page":"Tutorial","title":"Threshold and constants","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For profile likelihood, we can calculate likelihood-based confidence intervals using a threshold. Since there are two unknown parameters, we use df=2 for simultaneous confidence intervals and df=1 for pointwise confidence interval. For more information, read Raue et. al's \"Exploiting Profile Likelihood\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"threshold_simu = find_threshold(0.95, 2, loss)\nthreshold_poin = find_threshold(0.95, 1, loss)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Furthermore, for the profile likelihood plots, we dropped the constants when finding the minimizer. We can add the constant back when making the profile likelihood plots.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pl_const_const_variance = likelihood_const(\"const_variance_error\"; times = times, sigma = 30)\npl_const_poisson = likelihood_const(\"poisson_error\"; data = noisy_data_incidence_infected)\npl_const = pl_const_const_variance + pl_const_poisson","category":"page"},{"location":"tutorial/#Profile-Likelihood","page":"Tutorial","title":"Profile Likelihood","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can now plot the profile likelihood. The algorithm implemented explore the profile likelihood by taking steps of equal size in both right and left directions. The first and second argument is the step size and number of steps to take for one direction respectively. The third argument tells the function what parameter we want to fix when plotting the profile likelihood. The seventh argument is the value at which the algorithm will stop computing points if the loss of the computed points is greater than the minimum loss plus the value. We will use the threshold computed earlier plus a small number so that the algorithm explore the profile likelihood a bit more.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The plot of the profile likelihood of β is shown below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"theta_beta, sol_beta = find_profile_likelihood(2e-8, 50, 1, fitted_params,\n[noisy_data_recovered, noisy_data_incidence_infected], [3], threshold_simu + 3, loss, prob,\nTsit5(), times, [obj_const_variance, obj_poisson], NOMADOpt(), [0.0, 0.0], [3.0, 3.0];\nincidence_obs = [4], solver_diff_opts=solver_diff_opts,\npl_const = pl_const,\nprint_status = false)\nPL_beta = plot(theta_beta, [sol_beta, (x) -> (threshold_simu + pl_const), (x) -> (threshold_poin + pl_const)],\nxlabel = L\"\\beta\", ylabel = L\"\\chi^2_{\\rm PL}\", yformatter = :plain, legend=:topright,\nlabels = [L\"\\chi^2_{\\rm PL}\" \"Simultaneous Threshold\" \"Pointwise Threshold\"], right_margin=5mm,\ndpi = 400)\nscatter!([fitted_params[1]], [loss + pl_const], color = \"orange\", labels = \"Fitted Parameter\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The plot of the profile likelihood of γ is shown below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"theta_gamma, sol_gamma = find_profile_likelihood(3e-4, 50, 2, fitted_params,\n[noisy_data_recovered, noisy_data_incidence_infected], [3], threshold_simu + 3, loss, prob,\nTsit5(), times, [obj_const_variance, obj_poisson], NOMADOpt(), [0.0, 0.0], [3.0, 3.0];\nincidence_obs = [4], solver_diff_opts=solver_diff_opts, pl_const = pl_const,\nprint_status = false)\nPL_gamma = plot(theta_gamma, [sol_gamma, (x) -> (threshold_simu + pl_const), (x) -> (threshold_poin + pl_const)],\nxlabel = L\"\\gamma\", ylabel = L\"\\chi^2_{\\rm PL}\", yformatter = :plain, legend=:topright,\nlabels = [L\"\\chi^2_{\\rm PL}\" \"Simultaneous Threshold\" \"Pointwise Threshold\"], right_margin=5mm,\ndpi = 400)\nscatter!([fitted_params[2]], [loss + pl_const], color = \"orange\", labels = \"Fitted Parameter\")","category":"page"},{"location":"tutorial/#Identifiability-analysis-and-confidence-interval-estimation","page":"Tutorial","title":"Identifiability analysis and confidence interval estimation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the confidence intervals are finite and the global minimum is unique, then the parameter is practically identifiable. If the conifdence interval is not finite, then the parameter is not practically identifiable. From the profile likelihood plots, the parameters β and γ are practically identifiable.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The confidence intervals are determined by the intercepts of the threshold and the profile likelihood plot. For this tutorial, we will find simultaneous confidence intervals. We use the Interpolations.jl package to make a linear interpolant of the points found.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beta_inter = linear_interpolation(theta_beta, sol_beta)\ngamma_inter = linear_interpolation(theta_gamma, sol_gamma)\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can use find_roots() from the ProfileLikelihood.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simultaneous confidence interval of β is 9953 cdot 10^-5 0000101.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ci_simu_beta_h = find_roots(beta_inter, theta_beta, threshold_simu + pl_const)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simultaneous confidence interval of γ is 009400102.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ci_simu_beta_v = find_roots(gamma_inter, theta_gamma, threshold_simu + pl_const)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
